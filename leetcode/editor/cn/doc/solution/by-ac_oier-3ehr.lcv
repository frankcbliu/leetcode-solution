## DFS

较为直观的做法是使用 `DFS`，在 `DFS`  过程中记录路径以及路径对应的元素和，当出现元素和为 `target`，且到达了叶子节点，说明找到了一条满足要求的路径，将其加入答案。

使用 `DFS` 的好处是在记录路径的过程中可以使用「回溯」的方式进行记录及回退，而无须时刻进行路径数组的拷贝。

代码：

* []

```Java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    int t;
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        t = target;
        dfs(root, 0, new ArrayList<>());
        return ans;
    }
    void dfs(TreeNode root, int cur, List<Integer> list) {
        if (root == null) return ;
        list.add(root.val);
        if (cur + root.val == t && root.left == null && root.right == null) ans.add(new ArrayList<>(list));
        dfs(root.left, cur + root.val, list);
        dfs(root.right, cur + root.val, list);
        list.remove(list.size() - 1);
    }
}
```

* []

```TypeScript
let ans: number[][]
let t
function pathSum(root: TreeNode | null, target: number): number[][] {
    ans = new Array<Array<number>>()
    t = target
    dfs(root, 0, new Array<number>())
    return ans
};
function dfs(root: TreeNode | null, cur: number, list: Array<number>): void {
    if (root == null) return 
    list.push(root.val)
    if (cur + root.val == t && root.left == null && root.right == null) ans.push(list.slice())
    dfs(root.left, cur + root.val, list)
    dfs(root.right, cur + root.val, list)
    list.pop()
}
```

* 时间复杂度：最坏情况所有路径均为合法路径，复杂度为 $O(n \times h)$
* 空间复杂度：最坏情况所有路径均为合法路径，复杂度为 $O(n \times h)$

---

## BFS

使用 `BFS` 的话，我们需要封装一个类/结构体 `TNode`，该结构体存储所对应的原始节点 `node`，到达 `node` 所经过的路径 `list`，以及对应的路径和 `tot`。

由于 `BFS` 过程并非按照路径进行（即相邻出队的节点并非在同一路径），因此我们每次创建新的 `TNode` 对象时，需要对路径进行拷贝操作。

代码：

* []

```Java
class Solution {
    class Node {
        TreeNode node;
        List<Integer> list;
        int tot;
        Node (TreeNode _node, List<Integer> _list, int _tot) {
            node = _node; list = new ArrayList<>(_list); tot = _tot;
            list.add(node.val); tot += node.val;
        }
    }
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        List<List<Integer>> ans = new ArrayList<>();
        Deque<Node> d = new ArrayDeque<>();
        if (root != null) d.addLast(new Node(root, new ArrayList<>(), 0));
        while (!d.isEmpty()) {
            Node t = d.pollFirst();
            if (t.tot == target && t.node.left == null && t.node.right == null) ans.add(t.list);
            if (t.node.left != null) d.addLast(new Node(t.node.left, t.list, t.tot));
            if (t.node.right != null) d.addLast(new Node(t.node.right, t.list, t.tot));
        }
        return ans;
    }
}
```

* []

```Typescript
class TNode {
    node: TreeNode
    tot: number
    list: Array<number>
    constructor(node: TreeNode, tot: number, list: Array<number>) {
        this.node = node; this.tot = tot; this.list = list.slice();
        this.list.push(node.val)
        this.tot += node.val
    }
}
function pathSum(root: TreeNode | null, target: number): number[][] {
    const ans = new Array<Array<number>>()
    const stk = new Array<TNode>()
    let he = 0, ta = 0
    if (root != null) stk[ta++] = new TNode(root, 0, new Array<number>())
    while (he < ta) {
        const t = stk[he++]
        if (t.tot == target && t.node.left == null && t.node.right == null) ans.push(t.list)
        if (t.node.left != null) stk[ta++] = new TNode(t.node.left, t.tot, t.list)
        if (t.node.right != null) stk[ta++] = new TNode(t.node.right, t.tot, t.list)
    }
    return ans
};
```

* 时间复杂度：最坏情况所有路径均为合法路径，复杂度为 $O(n \times h)$
* 空间复杂度：最坏情况所有路径均为合法路径，复杂度为 $O(n \times h)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
