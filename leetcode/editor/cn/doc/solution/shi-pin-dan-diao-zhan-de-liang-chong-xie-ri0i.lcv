我们需要计算 $\textit{nums}_2[i]$ 的**下一个更大元素**的值（注意是值不是下标），这是单调栈的标准应用，请看 [单调栈【基础算法精讲 26】](https://www.bilibili.com/video/BV1VN411J7S7/)。

计算下一个更大元素可以**从右到左**遍历，也可以**从左到右**遍历，这两种方法都在视频中讲了。

## 方法一：从右到左

从右往左倒着遍历，栈中记录下一个更大元素的「候选项」。

由于左边更大元素会「挡住」右边更小的元素，所以右边更小的元素是无用信息（不会成为左边元素的下一个更大元素），这会导致栈底（右边）大，栈顶（左边）小。

对于本题，先把 $\textit{nums}_1$ 的每个元素及其下标记录到一个哈希表 $\textit{idx}$ 中。然后遍历 $\textit{nums}_2$，维护单调栈。如果栈不为空且 $x=\textit{nums}_2[i]$ 在 $\textit{nums}_1$ 中，则把栈顶元素记录到答案 $\textit{ans}[\textit{idx}[x]]$ 中。

* [sol-Python3]

```py
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        idx = {x: i for i, x in enumerate(nums1)}
        ans = [-1] * len(nums1)
        st = []
        for x in reversed(nums2):
            while st and x >= st[-1]:
                # 由于 x 的出现，栈顶元素永远不会是左边元素的「下一个更大元素」
                st.pop()
            if st and x in idx:  # x 在 nums1 中
                ans[idx[x]] = st[-1]  # 记录答案
            st.append(x)
        return ans
```

* [sol-Java]

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n = nums1.length;
        Map<Integer, Integer> idx = new HashMap<>(n, 1); // 预分配空间
        for (int i = 0; i < n; i++) {
            idx.put(nums1[i], i);
        }

        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Deque<Integer> st = new ArrayDeque<>();

        for (int i = nums2.length - 1; i >= 0; i--) {
            int x = nums2[i];
            while (!st.isEmpty() && x >= st.peek()) {
                // 由于 x 的出现，栈顶元素永远不会是左边元素的「下一个更大元素」
                st.pop();
            }
            if (!st.isEmpty() && idx.containsKey(x)) { // x 在 nums1 中
                ans[idx.get(x)] = st.peek(); // 记录答案
            }
            st.push(x);
        }
        return ans;
    }
}
```

* [sol-C++]

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> idx;
        for (int i = 0; i < nums1.size(); i++) {
            idx[nums1[i]] = i;
        }
        vector<int> ans(nums1.size(), -1);
        stack<int> st;
        for (int i = nums2.size() - 1; i >= 0; i--) {
            int x = nums2[i];
            while (!st.empty() && x >= st.top()) {
                // 由于 x 的出现，栈顶元素永远不会是左边元素的「下一个更大元素」
                st.pop();
            }
            if (!st.empty() && idx.contains(x)) { // x 在 nums1 中
                ans[idx[x]] = st.top(); // 记录答案
            }
            st.push(x);
        }
        return ans;
    }
};
```

* [sol-Go]

```go
func nextGreaterElement(nums1, nums2 []int) []int {
    idx := make(map[int]int, len(nums1)) // 预分配空间
    for i, x := range nums1 {
        idx[x] = i
    }
    ans := make([]int, len(nums1))
    for i := range ans {
        ans[i] = -1
    }
    st := []int{}
    for i := len(nums2) - 1; i >= 0; i-- {
        x := nums2[i]
        for len(st) > 0 && x >= st[len(st)-1] {
            // 由于 x 的出现，栈顶元素永远不会是左边元素的「下一个更大元素」
            st = st[:len(st)-1]
        }
        if len(st) > 0 { // x 在 nums1 中
            if j, ok := idx[x]; ok {
                ans[j] = st[len(st)-1] // 记录答案
            }
        }
        st = append(st, x)
    }
    return ans
}
```

* [sol-JavaScript]

```js
var nextGreaterElement = function(nums1, nums2) {
    const idx = new Map();
    nums1.forEach((x, i) => idx.set(x, i));
    const ans = Array(nums1.length).fill(-1);
    const st = [];
    for (let i = nums2.length - 1; i >= 0; i--) {
        const x = nums2[i];
        while (st.length && x >= st[st.length - 1]) {
            // 由于 x 的出现，栈顶元素永远不会是左边元素的「下一个更大元素」
            st.pop();
        }
        if (st.length && idx.has(x)) { // x 在 nums1 中
            ans[idx.get(x)] = st[st.length - 1]; // 记录答案
        }
        st.push(x);
    }
    return ans;
};
```

* [sol-Rust]

```rust
use std::collections::HashMap;

impl Solution {
    pub fn next_greater_element(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {
        let idx = nums1.iter().enumerate().map(|(i, &x)| (x, i)).collect::<HashMap<_, _>>();
        let mut ans = vec![-1; nums1.len()];
        let mut st = vec![];
        for &x in nums2.iter().rev() {
            while let Some(&top) = st.last() {
                if x < top {
                    break;
                }
                // 由于 x 的出现，栈顶元素永远不会是左边元素的「下一个更大元素」
                st.pop();
            }
            if !st.is_empty() {
                if let Some(&j) = idx.get(&x) { // x 在 nums1 中
                    ans[j] = *st.last().unwrap(); // 记录答案
                }
            }
            st.push(x);
        }
        ans
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n+m)$，其中 $n$ 是 $\textit{nums}_1$ 的长度，$m$ 是 $\textit{nums}_2$ 的长度。虽然我们写了个二重循环，但站在每个元素的视角看，这个元素在二重循环中最多入栈出栈各一次，因此二重循环的循环次数**之和**是 $\mathcal{O}(m)$。
- 空间复杂度：$\mathcal{O}(n+m)$。

## 方法二：从左到右

栈中记录还没算出「下一个更大元素」的那些数。

只要遍历到比栈顶元素更大的数，就意味着栈顶元素找到了答案，记录答案，并弹出栈顶。

注意我们只需把在 $\textit{nums}_1$ 中的元素入栈。**这种写法的空间复杂度比方法一更优**，见下面的复杂度分析。

* [sol-Python3]

```py
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        idx = {x: i for i, x in enumerate(nums1)}
        ans = [-1] * len(nums1)
        st = []
        for x in nums2:
            while st and x > st[-1]:
                # x 是栈顶的下一个更大元素
                # 既然栈顶已经算出答案，弹出
                ans[idx[st.pop()]] = x  # 记录答案
            if x in idx:  # x 在 nums1 中
                st.append(x)  # 只需把在 nums1 中的元素入栈
        return ans
```

* [sol-Java]

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n = nums1.length;
        Map<Integer, Integer> idx = new HashMap<>(n, 1); // 预分配空间
        for (int i = 0; i < n; i++) {
            idx.put(nums1[i], i);
        }

        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Deque<Integer> st = new ArrayDeque<>();

        for (int x : nums2) {
            while (!st.isEmpty() && x > st.peek()) {
                // x 是栈顶的下一个更大元素
                // 既然栈顶已经算出答案，弹出
                ans[idx.get(st.pop())] = x; // 记录答案
            }
            if (idx.containsKey(x)) { // x 在 nums1 中
                st.push(x); // 只需把在 nums1 中的元素入栈
            }
        }
        return ans;
    }
}
```

* [sol-C++]

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, int> idx;
        for (int i = 0; i < nums1.size(); i++) {
            idx[nums1[i]] = i;
        }
        vector<int> ans(nums1.size(), -1);
        stack<int> st;
        for (int x : nums2) {
            while (!st.empty() && x > st.top()) {
                // x 是栈顶的下一个更大元素
                // 既然栈顶已经算出答案，弹出
                ans[idx[st.top()]] = x; // 记录答案
                st.pop();
            }
            if (idx.contains(x)) { // x 在 nums1 中
                st.push(x); // 只需把在 nums1 中的元素入栈
            }
        }
        return ans;
    }
};
```

* [sol-Go]

```go
func nextGreaterElement(nums1, nums2 []int) []int {
    idx := make(map[int]int, len(nums1)) // 预分配空间
    for i, x := range nums1 {
        idx[x] = i
    }
    ans := make([]int, len(nums1))
    for i := range ans {
        ans[i] = -1
    }
    st := []int{}
    for _, x := range nums2 {
        for len(st) > 0 && x > st[len(st)-1] {
            // x 是栈顶的下一个更大元素
            // 既然栈顶已经算出答案，弹出
            ans[idx[st[len(st)-1]]] = x // 记录答案
            st = st[:len(st)-1]
        }
        if _, ok := idx[x]; ok { // x 在 nums1 中
            st = append(st, x) // 只需把在 nums1 中的元素入栈
        }
    }
    return ans
}
```

* [sol-JavaScript]

```js
var nextGreaterElement = function(nums1, nums2) {
    const idx = new Map();
    nums1.forEach((x, i) => idx.set(x, i));
    const ans = Array(nums1.length).fill(-1);
    const st = [];
    for (const x of nums2) {
        while (st.length && x > st[st.length - 1]) {
            // x 是栈顶的下一个更大元素
            // 既然栈顶已经算出答案，弹出
            ans[idx.get(st.pop())] = x; // 记录答案
        }
        if (idx.has(x)) { // x 在 nums1 中
            st.push(x); // 只需把在 nums1 中的元素入栈
        }
    }
    return ans;
};
```

* [sol-Rust]

```rust
use std::collections::HashMap;

impl Solution {
    pub fn next_greater_element(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {
        let idx = nums1.iter().enumerate().map(|(i, &x)| (x, i)).collect::<HashMap<_, _>>();
        let mut ans = vec![-1; nums1.len()];
        let mut st = vec![];
        for x in nums2 {
            while let Some(top) = st.last() {
                if x <= *top {
                    break;
                }
                // x 是栈顶的下一个更大元素
                // 既然栈顶已经算出答案，弹出
                ans[idx[top]] = x; // 记录答案
                st.pop();
            }
            if idx.contains_key(&x) { // x 在 nums1 中
                st.push(x); // 只需把在 nums1 中的元素入栈
            }
        }
        ans
    }
}
```

#### 复杂度分析

- 时间复杂度：$\mathcal{O}(n+m)$，其中 $n$ 是 $\textit{nums}_1$ 的长度，$m$ 是 $\textit{nums}_2$ 的长度。虽然我们写了个二重循环，但站在每个元素的视角看，这个元素在二重循环中最多入栈出栈各一次，因此二重循环的循环次数**之和**是 $\mathcal{O}(m)$。
- 空间复杂度：$\mathcal{O}(n)$。由于只把在 $\textit{nums}_1$ 中的元素入栈，所以栈的大小不会超过 $n$。注意题目保证 $\textit{nums}_2$ 的所有元素互不相同，所以栈中没有相同元素。

## 分类题单

[如何科学刷题？](https://leetcode.cn/circle/discuss/RvFUtj/)

1. [滑动窗口（定长/不定长/多指针）](https://leetcode.cn/circle/discuss/0viNMK/)
2. [二分算法（二分答案/最小化最大值/最大化最小值/第K小）](https://leetcode.cn/circle/discuss/SqopEo/)
3. [单调栈（基础/矩形面积/贡献法/最小字典序）](https://leetcode.cn/circle/discuss/9oZFK9/)
4. [网格图（DFS/BFS/综合应用）](https://leetcode.cn/circle/discuss/YiXPXW/)
5. [位运算（基础/性质/拆位/试填/恒等式/思维）](https://leetcode.cn/circle/discuss/dHn9Vk/)
6. [图论算法（DFS/BFS/拓扑排序/最短路/最小生成树/二分图/基环树/欧拉路径）](https://leetcode.cn/circle/discuss/01LUak/)
7. [动态规划（入门/背包/状态机/划分/区间/状压/数位/数据结构优化/树形/博弈/概率期望）](https://leetcode.cn/circle/discuss/tXLS3i/)
8. [常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）](https://leetcode.cn/circle/discuss/mOr1u6/)
9. [数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）](https://leetcode.cn/circle/discuss/IYT3ss/)
10. [贪心算法（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）](https://leetcode.cn/circle/discuss/g6KTKL/)

[我的题解精选（已分类）](https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/SOLUTIONS.md)

欢迎关注 [B站@灵茶山艾府](https://space.bilibili.com/206214)
