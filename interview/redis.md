# Redis

## Redis 基础

### Redis 为什么那么快？
- 纯内存操作
- 高效的I/O模型
  - 使用单线程事件循环配合I/O多路复用技术，让单个线程可以同时处理多个儿网络连接上的I/O事件
- 优化的内部数据结构
- 简洁高效的通信协议

![why-redis-fast](../imgs/why-redis-fast.png)

### Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？

当有序集合对象(ZSet)同时满足下面两个条件时，使用 `ziplist`:
- ZSet 保存的键值对数量少于 128 个
- 每个元素的长度小于 64 字节

如果不满足上述两个条件，那么使用 `skiplist`。

假设元素个数为`n`，那么对应 `k` 层索引的元素个数 `n_k` 计算公式为:
```
n_k = n / 2^k
```

#### 平衡树 vs 跳表
平衡树(AVL)的插入、删除、查询操作时间复杂度均为 `O(logN)`

> 跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。

跳表的插入、删除、查询的操作时间复杂度也为 `O(logN)`

#### 红黑树 vs 跳表
红黑树的查询性能略逊色于 AVL, 但插入、删除操作的性能更高；
红黑树的插入、删除和查询的时间复杂度和跳表一样都是 `O(log n)`

#### B+树 vs 跳表

B+树的特点：
- 多叉树结构：它是一棵多叉树，每个节点可以包含多个子节点，减小了树的高度，查询效率高。
- 存储效率高:其中非叶子节点存储多个 key，叶子节点存储 value，使得每个节点更够存储更多的键，根据索引进行范围查询时查询效率更高。
- 平衡性：它是绝对的平衡，即树的各个分支高度相差不大，确保查询和插入时间复杂度为 O(log n) 。
- 顺序访问：叶子节点间通过链表指针相连，范围查询表现出色。
- 数据均匀分布：B+树插入时可能会导致数据重新分布，使得数据在整棵树分布更加均匀，保证范围查询和删除效率。

所以，B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。
对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。

#### Redis 作者自己的理由
```
有几个原因：
1、它们不是很占用内存。这主要取决于你。改变节点拥有给定层数的概率的参数，会使它们比 B 树更节省内存。
2、有序集合经常是许多 ZRANGE 或 ZREVRANGE 操作的目标，也就是说，以链表的方式遍历跳表。通过这种操作，跳表的缓存局部性至少和其他类型的平衡树一样好。
3、它们更容易实现、调试等等。例如，由于跳表的简单性，我收到了一个补丁（已经在 Redis 主分支中），用增强的跳表实现了 O(log(N))的 ZRANK。
```


## Redis 持久化机制
- 快照(RDB, Redis Database)
- 只追加文件(AOF, Append Only File)
- RDB + AOF: 混合使用

### RDB 持久化
核心逻辑：在指定的间隔时间内，将 Redis 内存中的全量数据生成一个二进制快照文件(.rdb)，保存到磁盘。

RDB 创造快照是否会阻塞主线程？
有两种方式：
- `save`: 同步保存操作，会阻塞 `Redis`主线程(Redis 是单线程)
- `bgsave`: fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。

### AOF 持久化
核心逻辑：以 “追加日志” 的方式，记录 Redis 执行的所有写命令（如 SET、HSET、SETBIT 等），重启时通过重新执行这些命令恢复数据。

与 RDB 相比，AOF持久化的实时性更好。
AOF 默认并不开启(6.0以后默认开启), 可以通过命令 `appendonly yes`开启。

开启 AOF 后每执行一条更改 Redis 数据的命令，Redis 都会将该命令写入 AOF 缓冲区中

### AOF重点逻辑: 刷盘策略
- 每条命令进行刷盘
- 每秒刷盘
- 由操作系统决定刷盘时机，性能最好，但可能丢失数据。
```
# appendfsync always  # 每写1条命令刷盘，最安全但性能最差
appendfsync everysec # 每秒刷盘，平衡性能和安全性（推荐）
# appendfsync no      # 由操作系统决定刷盘时机，性能最好但数据丢失风险高
```

### AOF重点逻辑：AOF 重写
AOF 运行一段时间后会产生大量冗余命令（比如多次修改同一个键），需执行 `BGREWRITEAOF`（后台重写）压缩日志：
重写后，AOF 文件会只保留 “恢复数据所需的最小命令集”（比如一个键被修改 100 次，重写后仅保留最终的 SET 命令）。

### RDB 和 AOF 同时开启，重启时优先用哪个？
优先用 AOF

### fork 子进程会阻塞主进程吗？
fork 过程会短暂阻塞主进程，数据量越大，阻塞时间越长。因此尽量在低峰期执行 `BGSAVE/BGREWRITEAOF`

### 为什么 AOF 是执行完命令再记录？
而 MySQL 的 redo log 是执行命令前先记录，这是为什么呢？

好处：
- 避免额外的检查开销，AOF 记录日志不会对命令进行语法检查
- 在执行完命令后再记录，不会阻塞当前命令的执行
- Redis 的操作是内存修改，具备原子性，执行成功再记录性能更高，事务失败也不需要回滚。

风险：
- 如果刚执行完命令，Redis 就宕机，那么数据就会丢失；
- 可能会阻塞后续其他命令的执行

## Redis 线程模型

### Redis 单线程模型
基于 `Reactor` 模式设计开发了一套高效的事件处理机制。

```
多个socket(客户端连接) -> I/O多路复用 -> 文件事件处理器(file event handler) -> 事件处理器
```

Redis 6.0 之前为什么只用单线程模型:
- 单线程编程容易并且更容易维护；
- Redis 的性能瓶颈不在 CPU，主要在内存和网络；
- 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

### 6.0之后引入多线程

主要是为了处理网络`I/O`读写性能，这部分是 Redis 的性能瓶颈。(默认是禁用多线程的, 性能提升不高)

## Redis 内存管理
为什么一般情况下会给缓存数据设置过期时间：
- 因为内存珍贵，如果没有过期时间，内存可能会越来越大，直到 OOM
- 业务需要，有些数据就是只在一段时间内生效，比如 token

### Redis 是如何判断数据是否过期的？
- TTL/PTTL命令，TTL 是秒级，PTTL 是毫秒级
- 存在数据过期字典(key: 数据, value: long long 类型的时间戳)
- 先查过期字典，如果存在就判断是否过期，过期会删除后返回 null

### Redis 过期删除策略
- 惰性删除：查询时发现过期了才执行删除(CPU友好，内存不友好)
- 定期删除：周期性抽查，删除过期 key, 如果过期比例高，则继续抽查下一批，避免单次检查耗时过长。(内存友好，CPU 不友好)
- 内存淘汰策略: 内存不足时，根据内存淘汰策略删除key
  - volatile-lru: 设置了过期时间的键中-删除最少使用的键
  - volatile-ttl: 设置了过期时间的键中-删除剩余过期时间最少的键
  - volatile-random: 设置了过期时间的键中-随机删除
  - allkeys-lru: 从所有键中-删除最近最少使用的键(lru)
  - allkeys-random: 从所有键中-随机删除
  - volatile-lfu: 设置了过期时间的键中-删除最不经常使用的键(4.0版本以后新增)
  - allkeys-lfu: 从所有键中-删除最不经常使用的键(4.0版本以后新增)

Redis 采取的是定期删除 + 惰性删除 结合的删除策略。

## Redis 性能操作

### 使用批量操作减少网络传输

一个 Redis 命令可以简化为四步：
```
1.发送命令
2.命令排队
3.执行命令
4.返回结果
```

- 原生批量操作命令: `MGET`、`MSET`等
- pipeline: 将一批命令封装成一组，减少网络传输的耗时
- Lua脚本: 同样支持批量执行多个命令，一个 lua 脚本可以视为一条命令

需要注意的是，redis 集群下，不同的 key 可能存在不同的实例上，批量操作时无法保证所有key 都在一台机器上。

### 大量key集中过期问题
因为 Redis 采用的是定期删除 + 惰性删除，如果同时存在大量的 key 过期，主线程会卡在删除过期 key 上，影响客户端请求的处理。

解决办法:
- 给 key 设置随机过期时间
- 开启lazy-free, 使用异步方式延迟释放 key 使用的内存, 将该操作交给单独的子线程处理，避免阻塞主线程。

## Redis BigKey
判断标准:
- 比如 String 类型的 value 超过 1MB
- 复合类型的 value 的元素数量超过 5000

## Redis HotKey
判断标准: 请求占比较高

## 缓存穿透
大量请求的 key 不合理，不在缓存中，也不在数据库中。

解决办法:
- 缓存无效key
- 布隆过滤器: 可以判断一定不存在，但不一定能判断出存在。
  - 这样可以过滤大量无效的请求
- 接口限流

## 缓存击穿
比如缓存过期，然后大量请求直接打到数据库上，导致数据库的处理压力较大。

解决办法:
- 永不过期
- 提前预热
- 加锁，确保只有一个请求去更新 mysql 的数据到缓存

### 缓存穿透 vs 缓存击穿
缓存穿透的数据既不在缓存中，也不在数据库中；缓存击穿的数据不在缓存中，但一般存在于数据库中。

## 缓存雪崩
缓存中大量数据同时失效，导致大量请求打到数据库层面，对数据库造成巨大压力。

解决办法:
- 设置随机的过期时间
- 提前预热
- 持久缓存策略

### 缓存预热的解决方案
- 使用定时任务
- 使用消息队列

### 缓存雪崩vs缓存击穿
缓存雪崩是缓存中大量数据失效，而缓存击穿是单点问题。


## 如何保证缓存和数据库的一致性?

### Cache Aside Pattern(缓存旁路模式)

- 读操作:
  - 先尝试从缓存读取数据。
  - 如果缓存命中，直接返回数据。
  - 如果缓存未命中，从数据库查询数据，将查到的数据放入缓存并返回数据。
- 写操作:
  - 先更新数据库。
  - 再直接删除缓存中对应的数据。

### 缓存利用率与缓存一致性
先考虑最简单的更新模式：
- 全量缓存数据(缓存利用率差)
- 定时更新缓存(缓存一致性低，更新窗口期内缓存和数据库数据不一致)

### 怎么提升缓存利用率?
只缓存热点数据，也就是读取时把数据从 mysql 写入 redis

### 怎么提升缓存一致性?
在写入数据时，同时写入 mysql 和 redis。问题来了，先写 mysql 还是先写 redis 呢?

- 先写 mysql 再写 redis
  - 写 mysql 成功，但是写 redis 失败: 缓存读取时读取的旧数据, 待缓存过期后才能读取到新数据；(存在一段时间的不一致)
- 先写 redis 再写 mysql
  - 写 redis 成功，但是写 mysql 失败: 缓存读取时会读取到新数据，但是缓存过期后又变成旧数据。(存在一段时间的不一致)

因此，考虑另一个方式: **删除缓存**:

- 先删缓存，再写 mysql:
  - 因为存在读写并发，比如 A删缓存 -> B读缓存 -> B更新缓存 -> A更新数据库，这种情况下，还是存在不一致。
- 先写 mysql 再删缓存:
  - 同样存在读写并发, 比如 A读数据库,得到旧值 -> B写数据库 -> B删缓存 -> A更新缓存

为什么先写 mysql 再删缓存:
-  更新数据库的缓存时间 + 写缓时间短，

### 如何保证第二步成功?
- 异步重试，使用消息队列提升重试的稳定性。

### 主从库延迟和延迟双删问题
主从库读写分离的情况下，其实跟缓存类似，也存在一致性问题。

延迟双删是在更新数据库，然后删除缓存的情况下，再延迟删除一次缓存，确保缓存被删掉。

