# Redis

## Redis 基础

### Redis 为什么那么快？
- 纯内存操作
- 高效的I/O模型
  - 使用单线程事件循环配合I/O多路复用技术，让单个线程可以同时处理多个儿网络连接上的I/O事件
- 优化的内部数据结构
- 简洁高效的通信协议

![why-redis-fast](../imgs/why-redis-fast.png)

### Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？

当有序集合对象(ZSet)同时满足下面两个条件时，使用 `ziplist`:
- ZSet 保存的键值对数量少于 128 个
- 每个元素的长度小于 64 字节

如果不满足上述两个条件，那么使用 `skiplist`。

假设元素个数为`n`，那么对应 `k` 层索引的元素个数 `n_k` 计算公式为:
```
n_k = n / 2^k
```

#### 平衡树 vs 跳表
平衡树(AVL)的插入、删除、查询操作时间复杂度均为 `O(logN)`

> 跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此，跳表中的插入和删除算法比平衡树的等效算法简单得多，速度也快得多。

跳表的插入、删除、查询的操作时间复杂度也为 `O(logN)`

#### 红黑树 vs 跳表
红黑树的查询性能略逊色于 AVL, 但插入、删除操作的性能更高；
红黑树的插入、删除和查询的时间复杂度和跳表一样都是 `O(log n)`

#### B+树 vs 跳表

B+树的特点：
- 多叉树结构：它是一棵多叉树，每个节点可以包含多个子节点，减小了树的高度，查询效率高。
- 存储效率高:其中非叶子节点存储多个 key，叶子节点存储 value，使得每个节点更够存储更多的键，根据索引进行范围查询时查询效率更高。
- 平衡性：它是绝对的平衡，即树的各个分支高度相差不大，确保查询和插入时间复杂度为 O(log n) 。
- 顺序访问：叶子节点间通过链表指针相连，范围查询表现出色。
- 数据均匀分布：B+树插入时可能会导致数据重新分布，使得数据在整棵树分布更加均匀，保证范围查询和删除效率。

所以，B+树更适合作为数据库和文件系统中常用的索引结构之一，它的核心思想是通过可能少的 IO 定位到尽可能多的索引来获得查询数据。
对于 Redis 这种内存数据库来说，它对这些并不感冒，因为 Redis 作为内存数据库它不可能存储大量的数据，所以对于索引不需要通过 B+树这种方式进行维护，只需按照概率进行随机维护即可，节约内存。

#### Redis 作者自己的理由
```
有几个原因：
1、它们不是很占用内存。这主要取决于你。改变节点拥有给定层数的概率的参数，会使它们比 B 树更节省内存。
2、有序集合经常是许多 ZRANGE 或 ZREVRANGE 操作的目标，也就是说，以链表的方式遍历跳表。通过这种操作，跳表的缓存局部性至少和其他类型的平衡树一样好。
3、它们更容易实现、调试等等。例如，由于跳表的简单性，我收到了一个补丁（已经在 Redis 主分支中），用增强的跳表实现了 O(log(N))的 ZRANK。
```


## Redis 持久化机制
- 快照(RDB, Redis Database)
- 只追加文件(AOF, Append Only File)
- RDB + AOF: 混合使用

### RDB 持久化
核心逻辑：在指定的间隔时间内，将 Redis 内存中的全量数据生成一个二进制快照文件(.rdb)，保存到磁盘。

RDB 创造快照是否会阻塞主线程？
有两种方式：
- `save`: 同步保存操作，会阻塞 `Redis`主线程(Redis 是单线程)
- `bgsave`: fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。

### AOF 持久化
核心逻辑：以 “追加日志” 的方式，记录 Redis 执行的所有写命令（如 SET、HSET、SETBIT 等），重启时通过重新执行这些命令恢复数据。

与 RDB 相比，AOF持久化的实时性更好。
AOF 默认并不开启(6.0以后默认开启), 可以通过命令 `appendonly yes`开启。

开启 AOF 后每执行一条更改 Redis 数据的命令，Redis 都会将该命令写入 AOF 缓冲区中

### AOF重点逻辑: 刷盘策略
- 每条命令进行刷盘
- 每秒刷盘
- 由操作系统决定刷盘时机，性能最好，但可能丢失数据。
```
# appendfsync always  # 每写1条命令刷盘，最安全但性能最差
appendfsync everysec # 每秒刷盘，平衡性能和安全性（推荐）
# appendfsync no      # 由操作系统决定刷盘时机，性能最好但数据丢失风险高
```

### AOF重点逻辑：AOF 重写
AOF 运行一段时间后会产生大量冗余命令（比如多次修改同一个键），需执行 `BGREWRITEAOF`（后台重写）压缩日志：
重写后，AOF 文件会只保留 “恢复数据所需的最小命令集”（比如一个键被修改 100 次，重写后仅保留最终的 SET 命令）。

### RDB 和 AOF 同时开启，重启时优先用哪个？
优先用 AOF

### fork 子进程会阻塞主进程吗？
fork 过程会短暂阻塞主进程，数据量越大，阻塞时间越长。因此尽量在低峰期执行 `BGSAVE/BGREWRITEAOF`

### 为什么 AOF 是执行完命令再记录？
而 MySQL 的 redo log 是执行命令前先记录，这是为什么呢？

好处：
- 避免额外的检查开销，AOF 记录日志不会对命令进行语法检查
- 在执行完命令后再记录，不会阻塞当前命令的执行
- Redis 的操作是内存修改，具备原子性，执行成功再记录性能更高，事务失败也不需要回滚。

风险：
- 如果刚执行完命令，Redis 就宕机，那么数据就会丢失；
- 可能会阻塞后续其他命令的执行
