# 数据库原理

## 三范式

- 1NF: 属性不可分
- 2NF: 1NF 基础上，不存在部分依赖
- 3NF: 2NF 基础上，不存在传递依赖

## 事务的 ACID 特性
- A（Atomicity）：原子性（通过 undo log 支持）
  - 事务要么完成，要么回滚
- C（Consistency）：一致性
  - 事务执行前后，数据库必须保持一致性状态，满足约束
- I（Isolation）：隔离性
  - 多个事务并发执行时，彼此互不影响
- D（Durability）：持久性（通过 redo log 支持）
  - 事务提交后，对数据的修改是永久的。
  - 通过 redo log 支持：先修改写入日志，再异步把数据写入磁盘

## 并发一致性问题

- 丢失修改:
  - a:0
  - T1: a:0 -> +10 -> a:10
  - T2: a:0 -> +20         -> a:20
  - 预期是 a:30, 但因为 T1 和 T2 的修改是并发的，导致 T1 的修改丢失了，最终 a:20, 不符合预期

- 读脏数据:
  - a:0
  - T1: a:0 -> +10 -> undo
  - T2:        a:10 -> +10 -> a:20
  - 预期是 a:10, 但因为 T2 读取到了 T1 事务中修改的数据，但 T1 撤销了，导致 T2 使用了脏数据

- 不可重复读：
  - a: 10
  - T1: a:10 -> ... -> a:20 -> ...
  - T2: a:10 -> +10 -> a:20
  - 事务 T1 两次读取 a 的值发生了变化

- 幻读：(本质上也是不可以重复读的一种)
  - n: 10
  - T1: Count(x):10 -> ... -> Count(x):11
  - T2:            INSERT x
  - 与不可重复读相比，粒度不太一样，幻读是表粒度的不可重复读;

## 隔离级别
- 读未提交(RU)
  - 存在所有并发一致性问题，但并发性能最高
- 读已提交(RC)
  - 存在不可重复读问题，解决了修改丢失、脏读问题
- 可重复读(RR)
  - 仍然存在幻读问题，但解决了脏读、不可重复读等问题
  - MySQL InnoDB 的可重复读级别通过 MVCC+行锁&间隙锁，解决了大部分幻读问题
- 串行化
  - 可以解决所有并发一致性问题，但因为不是并发，效率极低

# MySQL

## InnoDB引擎 vs MyISAM引擎(不建议使用)
- InnoDB引擎:
  - 聚簇索引、支持事务
  - 支持表级、行级锁
  - 支持外键、热备份(不锁表)
- MyISAM引擎:
  - 非聚簇索引，不支持事务
  - 只支持表级锁
  - 支持压缩表和空间数据索引、仅支持冷备份

## 索引的底层结构
- 哈希表
- B 树
  - 数据存储在任意节点
- B+树
  - 数据只存储在叶子节点
  - 叶子节点之间通过双向链表连接
  - 字符串作为主键的话，依赖排序规则

## 聚簇索引 vs 非聚簇索引
- 聚簇索引：叶子节点上存储行数据（如主键索引）
- 非聚簇索引：叶子节点上存储主键的值（如普通索引、非主键的唯一索引）

## 索引优化
- 覆盖索引：查询列都在索引中，无需回表。（本质上是空间换时间）
- 索引下推：（本质上是用 CPU 时间换磁盘 IO 时间）
  - 本质上拿到二级索引数据后，在 Server 层提前进行过滤，而不是直接回表；
  - 可以大幅度减少回表次数
  - 只用于二级索引（主键索引是聚簇索引，不需要回表）
  - 下推字段必须要在索引上，否则没办法提前过滤
- 联合索引：
  - 减少索引数量：(a,b,c) 等同于: (a), (a,b), (a,b,c) 三个索引
  - 用于实现覆盖索引，可以减少回表次数
  - 优化排序：如果 order by a,b，索引本身已经排序了
- 最左前缀匹配原则：
  - 索引的有序性是有层级依赖的：假如有(a,b,c)联合索引，b的有序性依赖于 a 的有序性，c的有序性依赖于(a,b)的有序性
  - 与前缀索引的区别：前缀索引是指使用某一列的前几个字符建立索引，以节省空间，但会降低区分度。(INDEX(last_name(10)))

## 三大日志
- Redo Log(InnoDB 独有的，隶属于存储引擎层)
  - 崩溃恢复，保证持久性
  - 更新数据时，会先写入 redo log, 再异步刷盘到磁盘，即使数据库崩溃，也可以通过 redo log 恢复已提交的事务
  - 提升性能：redo log 是顺序写，而写入磁盘是随机写

- Undo Log
  - 记录数据修改前的状态，事务回滚时恢复数据

- Binlog
  - 记录 SQL 语句或者变更的逻辑操作；
  - 主从同步时，通过 binlog 同步到 Slave 上，Slave 重放日志以同步数据


## 两阶段提交(2PC)
- Prepare 阶段:
  - 写入 redo log，将事务状态标记为 Prepare
- Commit 阶段:
  - 写入 binlog
  - 写入 redo log, 将事务状态标记为 Commit

## MVCC
mvcc 的实现依赖：隐藏字段、read view、undo log

- RR下，事务在第一个 Read 操作时，会建立 Read View；
- RC下，事务在每次 Read 操作时，都会建立 Read View；

### 如何解决不可重复读问题？
MVCC在可重复读隔离级别下，会一直使用第一次读取字段时创建的 ReadView，这样期间即使有新的事务提交，也不会对当前事务造成影响。

### 如何解决幻读的问题？
幻读的问题是范围内数据的变动，而 MVCC 只解决了单行数据的重复读问题，要解决幻读，还依赖间隙锁。

注意，本身幻读问题是出现在范围查询条件下的，如果查询本身是唯一索引的单值查询，只会用记录锁，不会用间隙锁(gap lock)与临键锁(next-key lock)。

如果是RR隔离级别，会使用间隙锁和临键锁来解决幻读问题；
如果是RC隔离级别，只会使用记录锁，解决不了幻读问题；

mysql的默认隔离级别是 RR，比较常用的是RC

### 关于间隙锁
索引的叶子节点之间按照有序链表排列，链表节点之间形成间隙（左开右开区间）

临键锁 = 记录锁 + 间隙锁，形成一个（左开右闭区间）

所以解决幻读的是 MVCC + 临键锁


## MySQL 自增值不连续的情况
- 自增初始值和自增步长设置不为 1
- 唯一键冲突
- 事务回滚
- 批量插入（如 insert...select 语句）

那么，为什么这么设计？核心还是为了提升性能，避免回滚自增值带来事务冲突，和加锁校验降低性能。


