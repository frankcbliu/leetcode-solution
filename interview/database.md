# 数据库原理

## 三范式

- 1NF: 属性不可分
- 2NF: 1NF 基础上，不存在部分依赖
- 3NF: 2NF 基础上，不存在传递依赖

## 事务的 ACID 特性
- A（Atomicity）：原子性（通过 undo log 支持）
  - 事务要么完成，要么回滚
- C（Consistency）：一致性
  - 事务执行前后，数据库必须保持一致性状态，满足约束
- I（Isolation）：隔离性
  - 多个事务并发执行时，彼此互不影响
- D（Durability）：持久性（通过 redo log 支持）
  - 事务提交后，对数据的修改是永久的。
  - 通过 redo log 支持：先修改写入日志，再异步把数据写入磁盘

## 并发一致性问题

- 丢失修改:
  - a:0
  - T1: a:0 -> +10 -> a:10
  - T2: a:0 -> +20         -> a:20
  - 预期是 a:30, 但因为 T1 和 T2 的修改是并发的，导致 T1 的修改丢失了，最终 a:20, 不符合预期

- 读脏数据:
  - a:0
  - T1: a:0 -> +10 -> undo
  - T2:        a:10 -> +10 -> a:20
  - 预期是 a:10, 但因为 T2 读取到了 T1 事务中修改的数据，但 T1 撤销了，导致 T2 使用了脏数据

- 不可重复读：
  - a: 10
  - T1: a:10 -> ... -> a:20 -> ...
  - T2: a:10 -> +10 -> a:20
  - 事务 T1 两次读取 a 的值发生了变化

- 幻读：(本质上也是不可以重复读的一种)
  - n: 10
  - T1: Count(x):10 -> ... -> Count(x):11
  - T2:            INSERT x
  - 与不可重复读相比，粒度不太一样，幻读是表粒度的不可重复读;

## 隔离级别
- 读未提交(RU)
  - 存在所有并发一致性问题，但并发性能最高
- 读已提交(RC)
  - 存在不可重复读问题，解决了修改丢失、脏读问题
- 可重复读(RR)
  - 仍然存在幻读问题，但解决了脏读、不可重复读等问题
  - MySQL InnoDB 的可重复读级别通过 MVCC+行锁&间隙锁，解决了大部分幻读问题
- 串行化
  - 可以解决所有并发一致性问题，但因为不是并发，效率极低

# MySQL

## InnoDB引擎 vs MyISAM引擎(不建议使用)
- InnoDB引擎:
  - 聚簇索引、支持事务
  - 支持表级、行级锁
  - 支持外键、热备份(不锁表)
- MyISAM引擎:
  - 非聚簇索引，不支持事务
  - 只支持表级锁
  - 支持压缩表和空间数据索引、仅支持冷备份

## 索引的底层结构
- 哈希表
- B 树
  - 数据存储在任意节点
- B+树
  - 数据只存储在叶子节点
  - 叶子节点之间通过双向链表连接
  - 字符串作为主键的话，依赖排序规则

## 聚簇索引 vs 非聚簇索引
- 聚簇索引：叶子节点上存储行数据（如主键索引）
- 非聚簇索引：叶子节点上存储主键的值（如普通索引、非主键的唯一索引）

## 索引优化
- 覆盖索引：查询列都在索引中，无需回表。（本质上是空间换时间）
- 索引下推：（本质上是用 CPU 时间换磁盘 IO 时间）
  - 本质上拿到二级索引数据后，在 Server 层提前进行过滤，而不是直接回表；
  - 可以大幅度减少回表次数
  - 只用于二级索引（主键索引是聚簇索引，不需要回表）
  - 下推字段必须要在索引上，否则没办法提前过滤
- 联合索引：
  - 减少索引数量：(a,b,c) 等同于: (a), (a,b), (a,b,c) 三个索引
  - 用于实现覆盖索引，可以减少回表次数
  - 优化排序：如果 order by a,b，索引本身已经排序了
- 最左前缀匹配原则：
  - 索引的有序性是有层级依赖的：假如有(a,b,c)联合索引，b的有序性依赖于 a 的有序性，c的有序性依赖于(a,b)的有序性
  - 与前缀索引的区别：前缀索引是指使用某一列的前几个字符建立索引，以节省空间，但会降低区分度。(INDEX(last_name(10)))


